Eamon Tracey
Distributed Systems Assignment 2
-----
I have implemented a simple yet robust RPC server that supports read and write access to a spreadsheet data structure stored running on a distinct machine.

When the server begins, it initializes an empty spreadsheet. Internally, the spreadsheet is stored as a dictionary where each key is a 2-tuple, representing a row-column pair, that maps to a value. For example, the spreadsheet {(1, 3): "data"} indicates that the spreadsheet has one populated cell in row 1 column 3 with the string "data". The spreadsheet supports five operations: insert, lookup, remove, query, and size, all of which are described in the assignment instructions.

After initializing the spreadsheet, the server begins listening on a specified port for incoming client connections. The server listens for a TCP connection and supports one client at a time. When a client connects, the server serves that client until the connection is closed, allowing another client to connect.

The client accesses the spreadsheet by sending a JSON message to the server. After processing, the server responds with a JSON message. The JSON messages are serialized more compactly with the pickle library. Further, all messages are prepended with 4 bytes that indicate the size of the message.
-----
A valid client message is a dictionary with two keys: "function" and "arguments". The "function" is a string that indicates what spreadsheet operation to perform (e.g., "insert"). The "arguments" is a dictionary containing keys that correspond to function parameters and values that correspond to the arguments. A successful server message is a dictionary with one "return" key contaning the value to return to the caller. The following examples demonstrate the five valid RPC operations:

spreadsheet_client.insert(2, 3, {4: "head"})
client message -> {"function": "insert", "arguments": {"row": 2, "col": 3, "value": {4: "head"}}}
server response -> {"return": None}

spreadsheet_client.lookup(2, 3)
client message -> {"function": "lookup", "arguments": {"row": 2, "col": 3}}
server response -> {"return": {4: "head"}}

spreadsheet_client.query(1, 1, 3, 2)
client message -> {"function": "query", "arguments": {"row": 1, "col": 1, "width": 3, "height": 2}}
server response -> {"return": {(2, 3): {4: "head"}}}

spreadsheet_client.size()
client message -> {"function": "size", "arguments": {}}
server response -> {"return": (2, 3)}

spreadsheet_client.remove(2, 3)
client message -> {"function": "remove", "arguments": {"row": 2, "col": 3}}
server response -> {"return": None}
-----
It is possible that the client sends an invalid message. For example, the client may attempt to access a negative row or column, which raises an exception in the spreadsheet. To accomodate this, the server passes exceptions back to the client via "exception_name" and "exception_message". The client may then raise the exception to the caller with the appropriate message. The following examples demonstrate RPC operations that result in exceptions:

spreadsheet_client.insert(-1, -1, "data")
client message -> {'function': 'insert', 'arguments': {'row': -1, 'col': -1, 'value': 'data'}}
server response -> {'exception_name': 'ValueError', 'exception_message': 'row -1 cannot be negative'}

spreadsheet_client.lookup(-1, -1)
client message -> {'function': 'lookup', 'arguments': {'row': -1, 'col': -1}}
server response -> {'exception_name': 'LookupError', 'exception_message': 'no data at row -1 column -1'}

Further, it is possible for the client to send garbage, unloadable data or a payload that does not have the proper "function" or "arguments" keys. In this event, the client responds with a generic exception:

~some broken client~
client message -> {}
server response -> {"exception_name": "ValueError", "exception_message": "an invalid or unsupported request was received"}
-----
